use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use std::path::Path;

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Lockfile {
    #[serde(default = "default_lock_version")]
    pub version: u32,

    #[serde(default)]
    pub packages: HashMap<String, LockedPackage>
}

fn default_lock_version() -> u32 {
    1
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedPackage {
    pub version: String,
    pub source: PackageSource,

    #[serde(default)]
    pub checksum: Option<String>,

    #[serde(default)]
    pub dependencies: HashMap<String, String>
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum PackageSource {
    Registry {
        #[serde(default = "default_registry")]
        registry: String
    },
    Git {
        url: String,
        commit: String
    },
    Path {
        path: String
    }
}

fn default_registry() -> String {
    "placeholder".to_string()
}

impl Lockfile {
    pub fn load(path: &Path) -> Result<Option<Self>, String> {
        if !path.exists() {
            return Ok(None);
        }

        let contents = std::fs::read_to_string(path)
            .map_err(|e| format!("Failed to read rift.lock: {}", e))?;

        let lockfile: Lockfile = toml::from_str(&contents)
            .map_err(|e| format!("Failed to parse rift.lock: {}", e))?;

        if lockfile.version > default_lock_version() {
            return Err(format!(
                "Lockfile was created by a newer version of Rift. \
                 Please upgrade Rift to version that supports lockfile v{}",
                lockfile.version
            ));
        }

        Ok(Some(lockfile))
    }

    pub fn save(&self, path: &Path) -> Result<(), String> {
        let contents = toml::to_string_pretty(path)
            .map_err(|e| format!("Failed to serialize rift.lock: {}", e))?;

        let with_header = format!(
            "# This file is automatically generated by Rift.\n\
             # It records the exact versions of dependencies for reproducible builds.\n\
             # Do NOT edit this file manually. Run `rift update` to refresh it.\n\n\
             {}", 
            contents
        );

        let temp_path = path.with_extension("lock.tmp");
        std::fs::write(&temp_path, with_header)
            .map_err(|e| format!("Failed to write rift.lock: {}", e))?;

        std::fs::rename(&temp_path, path)
            .map_err(|e| format!("Failed to finalize rift.lock: {}", e))?;

        Ok(())
    }

    pub fn get(&self, package_name: &str) -> Option<&LockedPackage> {
        self.packages.get(package_name)
    }

    pub fn insert(&mut self, name: String, package: LockedPackage) {
        self.packages.insert(name, package);
    }

    pub fn is_empty(&self) -> bool {
        self.packages.is_empty()
    }

    pub fn package_names(&self) -> Vec<&String> {
        self.packages.keys().collect()
    }
}

#[derive(Debug, Clone, Default)]
pub struct ResolvedGraph {
    pub packages: Vec<ResolvedPackage>
}

#[derive(Debug, Clone)]
pub struct ResolvedPackage {
    pub name: String,
    pub version: String,
    pub source: PackageSource,
    pub dependencies: Vec<String>,
    pub is_direct: bool
}

impl ResolvedGraph {
    pub fn new() -> Self {
        Self { packages: Vec::new() }
    }

    pub fn add(&mut self, package: ResolvedPackage) {
        self.packages.push(package);
    }

    pub fn to_lockfile(&self) -> Lockfile {
        let mut lockfile = Lockfile::default();

        for package in &self.packages {
            let locked = LockedPackage {
                version: package.version.clone(),
                source: package.source.clone(),
                checksum: None,
                dependencies: package.dependencies.iter().map(|dep| {
                    let version = self.packages.iter()
                        .find(|p| &p.name == dep)
                        .map(|p| p.version.clone())
                        .unwrap_or_else(|| "unknown".to_string());

                    (dep.clone(), version)
                }).collect()
            };

            lockfile.insert(package.name.clone(), locked);
        }

        lockfile
    }
}